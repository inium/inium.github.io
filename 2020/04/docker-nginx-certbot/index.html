<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#fff lang=ko-kr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Docker를 이용한 Reverse Proxy 서버 구성 및 자동화 - inlee's blog</title><meta name=theme-color><meta name=description content="이 글은 Docker를 이용해 NginX Reverse Proxy 서버를 구성한 후 2개의 웹 어플리케이션(Node.js App, phpmyadmin)과 MySQL을 설한 방법에 대한 내용이다. 그리고 웹 어플리케이션에 사용한 Let&rsquo;s Encrypt 인증서 발급 및 갱신, 확인 과정을 추가하였으며 마지막으로 이들을 자동화한 방법에 대해 소개하고자 한다.
배경 기존 위의 그림과 같이 Docker NginX(Reverse Proxy), 어플리케이션들, DB를 설정하여 사용했었다. docker compose를 이용하면 설정파일(.yml)에 정의한 Container 들이 한번에 실행이 가능해 자동화 할 수 있으나 NginX 환경설정 파일(.conf)의 도메인 이름과 인증서 저장 경로는 프로젝트에 의존적인 값이기 때문에 항상 수동으로 직접 입력하여 사용하였다."><meta name=author content="inlee"><link rel="preload stylesheet" as=style href=https://inium.github.io/main.min.css><link rel=preload as=image href=https://inium.github.io/theme.png><link rel=preload as=image href="https://avatars.githubusercontent.com/u/9084843?v=4"><link rel=preload as=image href=https://inium.github.io/github.svg><link rel=preload as=image href=https://inium.github.io/rss.svg><link rel=icon href=https://inium.github.io/favicon.ico><link rel=apple-touch-icon href=https://inium.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.101.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-153151440-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-153151440-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Docker를 이용한 Reverse Proxy 서버 구성 및 자동화"><meta property="og:description" content="이 글은 Docker를 이용해 NginX Reverse Proxy 서버를 구성한 후 2개의 웹 어플리케이션(Node.js App, phpmyadmin)과 MySQL을 설한 방법에 대한 내용이다. 그리고 웹 어플리케이션에 사용한 Let&rsquo;s Encrypt 인증서 발급 및 갱신, 확인 과정을 추가하였으며 마지막으로 이들을 자동화한 방법에 대해 소개하고자 한다.
배경 기존 위의 그림과 같이 Docker NginX(Reverse Proxy), 어플리케이션들, DB를 설정하여 사용했었다. docker compose를 이용하면 설정파일(.yml)에 정의한 Container 들이 한번에 실행이 가능해 자동화 할 수 있으나 NginX 환경설정 파일(.conf)의 도메인 이름과 인증서 저장 경로는 프로젝트에 의존적인 값이기 때문에 항상 수동으로 직접 입력하여 사용하였다."><meta property="og:type" content="article"><meta property="og:url" content="https://inium.github.io/2020/04/docker-nginx-certbot/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-03T19:59:23+00:00"><meta property="article:modified_time" content="2020-04-03T19:59:23+00:00"><meta itemprop=name content="Docker를 이용한 Reverse Proxy 서버 구성 및 자동화"><meta itemprop=description content="이 글은 Docker를 이용해 NginX Reverse Proxy 서버를 구성한 후 2개의 웹 어플리케이션(Node.js App, phpmyadmin)과 MySQL을 설한 방법에 대한 내용이다. 그리고 웹 어플리케이션에 사용한 Let&rsquo;s Encrypt 인증서 발급 및 갱신, 확인 과정을 추가하였으며 마지막으로 이들을 자동화한 방법에 대해 소개하고자 한다.
배경 기존 위의 그림과 같이 Docker NginX(Reverse Proxy), 어플리케이션들, DB를 설정하여 사용했었다. docker compose를 이용하면 설정파일(.yml)에 정의한 Container 들이 한번에 실행이 가능해 자동화 할 수 있으나 NginX 환경설정 파일(.conf)의 도메인 이름과 인증서 저장 경로는 프로젝트에 의존적인 값이기 때문에 항상 수동으로 직접 입력하여 사용하였다."><meta itemprop=datePublished content="2020-04-03T19:59:23+00:00"><meta itemprop=dateModified content="2020-04-03T19:59:23+00:00"><meta itemprop=wordCount content="1293"><meta itemprop=keywords content="docker,web,reverse proxy,nginx,let's encrypt,certbot,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker를 이용한 Reverse Proxy 서버 구성 및 자동화"><meta name=twitter:description content="이 글은 Docker를 이용해 NginX Reverse Proxy 서버를 구성한 후 2개의 웹 어플리케이션(Node.js App, phpmyadmin)과 MySQL을 설한 방법에 대한 내용이다. 그리고 웹 어플리케이션에 사용한 Let&rsquo;s Encrypt 인증서 발급 및 갱신, 확인 과정을 추가하였으며 마지막으로 이들을 자동화한 방법에 대해 소개하고자 한다.
배경 기존 위의 그림과 같이 Docker NginX(Reverse Proxy), 어플리케이션들, DB를 설정하여 사용했었다. docker compose를 이용하면 설정파일(.yml)에 정의한 Container 들이 한번에 실행이 가능해 자동화 할 수 있으나 NginX 환경설정 파일(.conf)의 도메인 이름과 인증서 저장 경로는 프로젝트에 의존적인 값이기 때문에 항상 수동으로 직접 입력하여 사용하였다."></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=https://inium.github.io/>inlee's blog</a>
<a class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"></a></div><a class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"></a>
<script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#fff"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"><a class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/inium target=_blank></a>
<a class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://inium.github.io/index.xml target=_blank></a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">Docker를 이용한 Reverse Proxy 서버 구성 및 자동화</h1><div class="text-sm opacity-60"><time>Apr 3, 2020</time>
<span class=mx-1>&#183;</span>
<span>inlee</span></div></header><section><p><img src=https://github.com/inium/docker-nginx-certbot/raw/master/docs/brief.png alt=개요></p><p>이 글은 Docker를 이용해 NginX Reverse Proxy 서버를 구성한 후 2개의 웹 어플리케이션(Node.js App, phpmyadmin)과 MySQL을 설한 방법에 대한 내용이다. 그리고 웹 어플리케이션에 사용한 Let&rsquo;s Encrypt 인증서 발급 및 갱신, 확인 과정을 추가하였으며 마지막으로 이들을 자동화한 방법에 대해 소개하고자 한다.</p><h3 id=배경>배경</h3><p>기존 위의 그림과 같이 Docker NginX(Reverse Proxy), 어플리케이션들, DB를 설정하여 사용했었다. <code>docker compose</code>를 이용하면 설정파일(.yml)에 정의한 Container 들이 한번에 실행이 가능해 자동화 할 수 있으나 NginX 환경설정 파일(.conf)의 도메인 이름과 인증서 저장 경로는 프로젝트에 의존적인 값이기 때문에 항상 수동으로 직접 입력하여 사용하였다.</p><p>그래서 NginX Reverse Proxy 실행 과정을 개선하여 직접 입력하는 불편함을 해결하였다. 또한 Let&rsquo;s Encrypt 인증서의 발급 과정을 추가함으로써 기본으로 https 서버가 실행이 되도록 하였다. 마지막으로 짧은 인증서 유효기간(3개월)을 자동으로 갱신을 하는 스크립트를 만든 후 <code>crontab</code> 에 등록하여 사용하였다.</p><p>이어지는 글은 NginX Reverse Proxy 서버 구성과 개선한 방법에 대한 내용이며 구현 결과는 아래 링크에 업로드 하였다.</p><ul><li><a href=https://github.com/inium/docker-nginx-certbot>https://github.com/inium/docker-nginx-certbot</a></li></ul><h3 id=docker-설정>Docker 설정</h3><h4 id=docker-compose>Docker Compose</h4><p>본 글의 구현은 <code>docker compose</code>를 이용해 동작하며 서버 설정, Let&rsquo;s Encrypt 설정으로 나누어 진다.</p><ul><li>서버 설정: Docker를 이용한 NginX Reverse Proxy, Node.js App, MySQL, phpmyadmin 설정. <a href=https://github.com/inium/docker-nginx-certbot/blob/master/docker-compose.yml>#링크</a>.</li><li>Let&rsquo;s Encrypt 설정: Docker Certbot를 이용한 Let&rsquo;s Encrypt 인증서 발급/갱신/확인 설정. <a href=https://github.com/inium/docker-nginx-certbot/blob/master/docker-compose-certbot.yml>#링크</a>.</li></ul><h4 id=docker-images>Docker Images</h4><p>사용한 Docker Image는 공식 Image와 해당 오픈 소스에서 공개하여 배포하는 Image를 이용하였으며 아래와 같다.</p><table><thead><tr><th>항목</th><th>Docker Image</th><th>설명</th></tr></thead><tbody><tr><td>Reverse Proxy</td><td><a href=https://hub.docker.com/_/nginx>nginx:1.17.8</a></td><td>Reverse Proxy 서버</td></tr><tr><td>App</td><td><a href=https://hub.docker.com/_/node>node:13.12.0</a></td><td>테스트 어플리케이션</td></tr><tr><td>Database Administrator</td><td><a href=https://hub.docker.com/r/phpmyadmin/phpmyadmin>phpmyadmin/phpmyadmin:latest</a></td><td>MySQL 웹 관리 도구</td></tr><tr><td>Database</td><td><a href=https://hub.docker.com/_/mysql>mysql:5.7.29</a></td><td>데이터베이스</td></tr><tr><td>Let&rsquo;s Encrypt 인증서</td><td><a href=https://hub.docker.com/r/certbot/certbot>certbot/certbot:latest</a></td><td>인증서 발급/갱신</td></tr></tbody></table><h4 id=docker-volume>Docker Volume</h4><p>데이터를 공유하기 위해 <code>Docker Volume</code>을 아래와 같이 사용하였으며 <code>docker compose</code> 설정파일(.yml) 들에 정의하였다.</p><ul><li>Container의 데이터는 Docker에서 제공하는 Volume 사용.</li><li>Container 내에서 사용할 설정 파일은 Host의 Volume 사용.</li></ul><h4 id=docker-network>Docker Network</h4><p>Container 이름으로 네트워크 통신을 하기 위해 별도의 Bridge 네트워크를 만든 후 사용하였으며 <code>docker compose</code> 설정파일(.yml) 들에 정의하였다.</p><p>Reverse Proxy 환경설정 파일 내의 upstream과 App에서 사용할 MySQL의 host 에 Container의 IP 대신 이름을 사용하였다. 참고로 IP 정보는 고정으로 지정되어 있지만 사용하지 않았다.</p><h3 id=환경변수>환경변수</h3><p>본 글의 Reverse Proxy 설정과 Let&rsquo;s Encrypt 인증서의 발급/갱신/확인은 <code>docker compose</code>를 이용해 실행한다. <code>docker compose</code>는 DotEnv(.env) 파일을 읽어들여 실행이 가능<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>하다. 그래서 서버 구성과 인증서 발급/갱신 과정에서 프로젝트별로 다르게 사용하는 정보들은 <code>.env</code> 에 정의하여 사용하도록 하였다.</p><p>사용한 환경변수 항목은 아래와 같다.</p><table><thead><tr><th>환경변수 이름</th><th>설명</th></tr></thead><tbody><tr><td>APP_URL</td><td>app 컨테이너(Container)에 접속할 URL. Reverse Proxy 설정에서 사용. <a href=https://www.securesign.kr/guides/kb/51>FQDN</a> 입력.</td></tr><tr><td>PHPMYADMIN_URL</td><td>phpmyadmin 컨테이너(Container)에 접속할 URL. Reverse Proxy 설정에서 사용. <a href=https://www.securesign.kr/guides/kb/51>FQDN</a> 입력.</td></tr><tr><td>MYSQL_ROOT_PASSWORD</td><td>MYSQL의 Root 계정 비밀번호</td></tr><tr><td>CERTBOT_CERT_EMAIL</td><td>Let&rsquo;s Encrypt 인증서 발급자의 이메일 주소</td></tr><tr><td>CERTBOT_CERT_NAME</td><td>Let&rsquo;s Encrypt 인증서 이름. App, phpmyadmin 인증서를 하나의 파일로 발급받아 사용(<a href=https://www.securesign.kr/guides/kb/29>멀티 도메인</a> 참조)하므로 파일을 저장할 디렉터리 이름으로 사용. Default로 mycert 라는 이름을 사용하도록 설정.</td></tr></tbody></table><h3 id=reverse-proxy-설정>Reverse Proxy 설정</h3><p>서버의 대문 역할을 하는 Reverse Proxy는 NginX를 이용하며 기존에는 NginX 환경설정 파일(.conf) 내 도메인 이름과 인증서 저장 경로는 프로젝트에 의존적인 값이기 때문에 항상 수동으로 직접 입력하여 사용하였다.</p><p>그래서 이를 보완하고 자동화하기 위한 방법으로 <code>docker compose</code>를 이용해 실행 시 NginX Docker Image에서 공식으로 제공하는 방법인 <code>envsubst</code><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> 명령을 이용해 NginX 설정 템플릿(template) 파일 내 환경변수(도메인 이름, SSL 인증서 저장 경로)들을 <code>.env</code> 파일의 값으로 대치한 후 그 결과를 NginX 설정 파일로 만들어 사용하였다<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>또한 보안을 위해 Let&rsquo;s Encrypt 인증서를 이용한 https 접속을 기본으로 하였다. http 서버 설정 템플릿은 Let&rsquo;s Encrypt 인증서 도전<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> 대응과 http to https Redirect 만을 구현하였다. <code>certbot</code>을 이용한 Let&rsquo;s Encrypt 인증서 발급은 <a href=https://certbot.eff.org/docs/using.html#webroot>webroot</a> 모드로 진행하기 때문에 인증서 발급 전 반드시 각 도메인별 http 서버(80 Port)가 실행되어 있어야 한다.</p><p>추가로 SSL 통신 암호화를 위해 암호 키 교환 과정에 사용되는 2048bit <a href=https://ko.wikipedia.org/wiki/%EB%94%94%ED%94%BC-%ED%97%AC%EB%A8%BC_%ED%82%A4_%EA%B5%90%ED%99%98>디피-헬먼 키 교환 (Diffie-Hellman Key Exchange)</a> 알고리즘을 적용 하였다.</p><p>전체 실행 과정은 아래와 같다.</p><ol><li><p>2048bit dhparam (디피-헬먼 키 교환 알고리즘에 사용되는 문자열)을 파일로 생성.</p></li><li><p>https 설정 템플릿에 사용하기 위해 정해진 파일 이름으로 생성하도록 구현</p></li><li><p>http 서버 템플릿을 이용해 Let&rsquo;s Encrypt 인증서 발급을 위한 http 서버 실행.</p></li><li><p>실행 시 <code>envsubst</code>를 이용해 http 설정 템플릿 내 환경변수(도메인 이름)를 <code>.env</code> 파일의 값으로 대치한 결과를 NginX 설정 파일로 만들어 실행.</p></li><li><p>Let&rsquo;s Encrypt 인증서 발급.</p></li><li><p>실행 시 <code>.env</code>의 이메일, cert name 참조.</p></li><li><p>발급받은 인증서를 이용해 https 서버 실행.</p></li><li><p>https 설정 템플릿에 1의 dhparam 파일 경로 추가(미리 정해진 파일 이름을 사전 입력).</p></li><li><p>http 설정 템플릿과 https 설정 템플릿을 합친 후 Reverse Proxy 재시작</p></li><li><p>재시작 시 2.1 의 과정과 마찬가지로 <code>envsubst</code>를 이용해 환경변수(도메인 이름, 인증서 저장 경로)들을 <code>.env</code> 값으로 대치한 결과를 NginX 설정 파일로 만들어 실행.</p></li><li><p>https 서버가 실행 완료되어 설정한 도메인 이름으로 접속 가능.</p></li></ol><h3 id=lets-encrypt-설정>Let&rsquo;s Encrypt 설정</h3><p>Let&rsquo;s Encrypt 인증서 발급/갱신을 담당하는 Docker 이미지인 <code>certbot</code>을 이용해 Let&rsquo;s Encrypt 인증서의 발급과 갱신, 유효기간 확인을 할 수 있도록 하였다. <code>certbot</code>은 인증서 갱신 및 발급 시에만 동작하며 완료하면 자동으로 삭제되도록 하였으며 <code>.env</code> 파일의 환경변수를 이용한다.</p><h4 id=인증서-발급>인증서 발급</h4><p>본 구현에서 인증서의 발급은 서버 <a href=https://github.com/inium/docker-nginx-certbot/blob/master/run.sh>실행 스크립트</a> 내 포함되어 있으며 <code>.env</code> 파일 내 도메인, 인증서 발급자 이메일, 인증서의 cert name을 이용해 발급을 진행하도록 하였다.</p><h4 id=인증서-갱신>인증서 갱신</h4><p>짧은 인증서 유효기간(3개월)을 자동으로 갱신하는 <a href=https://github.com/inium/docker-nginx-certbot/blob/master/certbot-renew.sh>갱신 스크립트</a>를 만들었으며 아래와 같이 <code>crontab</code>에 등록하여 사용할 수 있다.</p><pre tabindex=0><code class=language-crontab data-lang=crontab># 매주 일요일 한국시간 02:30 (UTC 17:30)
30 17 * * 0 /path/to/certbot-renew.sh
</code></pre><h4 id=인증서-유효기간-확인>인증서 유효기간 확인</h4><p>추가로 인증서의 유효기간을 확인할 수 있는 <a href=https://github.com/inium/docker-nginx-certbot/blob/master/certbot-certificates.sh>확인 스크립트</a>를 별도로 구현하였다.</p><h3 id=그-외-설정>그 외 설정</h3><h4 id=app>App</h4><p>테스트용 App을 Node.js로 구현하였다. DB 연결 결과와 서버 실행 결과를 출력하는 코드로 구성되어 있다.</p><h4 id=phpmyadmin>phpmyadmin</h4><p>MySQL을 웹에서 관리하기 위한 관리 도구이다. MySQL에 대한 의존성이 설정되어 있다.</p><h4 id=mysql>MySQL</h4><p>가장 많이 사용되는 데이터베이스며 <a href=https://github.com/inium/docker-nginx-certbot/blob/master/conf.d/mysql/my.cnf>my.cnf</a>에서 MySQL 실행과 관련된 추가 설정이 가능하도록 하였다.</p><h3 id=실행>실행</h3><p><a href=https://github.com/inium/docker-nginx-certbot>Github</a> 에 업로드된 프로젝트를 Clone 한 후 아래와 같이 실행한다.</p><ol><li>환경변수 설정: <code>.env.example</code> 파일을 <code>.env</code> 파일로 생성.</li><li>프로젝트 내 쉘 스크립트(.sh) 파일들에 실행권한(+x) 부여.</li><li><a href=https://github.com/inium/docker-nginx-certbot/blob/master/run.sh>실행 스크립트</a> 실행.</li></ol><h3 id=결론>결론</h3><p>이 글은 Docker 기반의 NginX를 이용한 Reverse Proxy 설정과 NginX의 설정파일 중 프로젝트에 의존적인 도메인, 인증서 경로를 수동으로 입력한 점을 개선하여 자동화한 방법에 대한 내용이다. 또한 이 과정에서 Let&rsquo;s Encrypt 인증서를 자동으로 적용하였다.</p><p>기존 Nginx Reverse Proxy를 설정할 때에는 http, https 설정이 미리 정의된 1개의 설정파일 템플릿을 이용하였었다. 인증서 발급받기 전 https 설정을 주석처리한 후 http 설정 항목에 도메인을 입력하여 서버를 실행하여 Let&rsquo;s Encrypt 인증서를 발급받는다. 인증서 발급이 완료되면 주석처리된 https 설정 항목에 도메인과 인증서 저장경로를 입력하고 주석을 해제한 후 재실행하여 https 서버로의 실행을 완료하였었다. 이 과정이 반복되다보니 불편함을 느끼게 되었고 개선을 하게 되었으며 이 글은 개인의 고민에 대한 작은 결과이다.</p><p>Docker를 이용한 Reverse Proxy 설정은 이미 많이 알려져 있기 때문에 Docker를 알고 있다면 어렵지 않을 것이라 생각한다.</p><p>구현결과(소스 코드)는 아래 Github 링크를 참조 바란다.</p><ul><li><a href=https://github.com/inium/docker-nginx-certbot>https://github.com/inium/docker-nginx-certbot</a></li></ul><h3 id=appendix-1-proxy란>Appendix 1: Proxy란</h3><p>Proxy는 컴퓨터 용어의 의미로 클라이언트-서버의 요청-응답을 중개하여 처리하는 것<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>을 말한다. Proxy Server는 Proxy를 처리하는 서버를 말하며 크게 Forward Proxy와 Reverse Proxy가 있다<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>.</p><ul><li>Forward Proxy: 클라이언트의 목적지와 요청을 대신 받아 목적지로 요청을 전달(Forward) 한 후 그 결과를 클라이언트에게 전달.</li><li>Reverse Proxy: 클라이언트의 목적지에서 요청을 받아 내부 서버(들)에서 처리한 결과를 클라이언트에게 전달.</li></ul><p>본 글에서는 하나의 서버에 2개의 어플리케이션을 구성하므로 입구 역할을 하는 Reverse Proxy 설정을 이용하였다.</p><h3 id=appedix-2-nginx-설정-파일-내-환경변수-사용>Appedix 2: NginX 설정 파일 내 환경변수 사용</h3><p>NginX는 환경변수 값을 직접 사용하는 것을 지원하지 않지만, <code>envsubst</code>를 이용해 NginX 설정 파일 내 <code>${환경변수값}</code> 와 같이 정의된 값을 환경변수의 값으로 치환한 후 새로운 파일로 만들어 사용하는 것을 소개하고 있다<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>.</p><p>NginX 환경설정 템플릿(default.template)이 <code>envsubst</code> 명령을 통해 사용되는 예시는 아래와 같다.</p><ol><li>NginX 환경설정 템플릿(default.template) 생성</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>### App (http)</span>
</span></span><span style=display:flex><span>server <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    listen 80;
</span></span><span style=display:flex><span>    server_name <span style=color:#e6db74>${</span>APP_URL<span style=color:#e6db74>}</span>;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ol start=2><li><code>.env</code> 파일 생성 및 값 입력</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>APP_URL<span style=color:#f92672>=</span>example.com
</span></span></code></pre></div><ol start=3><li><code>docker compose</code> 설정파일(.yml)의 environment 항목에 Container에서 사용할 <code>.env</code>의 값과 실행 시 nginx 설정파일(default.template) 내 환경 변수를 치환한 후 새로운 파일을 생성하는(default.conf) <code>envsubst</code> 명령어 입력.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>nginx-proxy</span>:
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>...</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>APP_URL=${APP_URL}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>command</span>: &gt;<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    /bin/bash -c &#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        envsubst \&#34;`env | awk -F = &#39;{printf \&#34; $$%s\&#34;, $$1}&#39;`\&#34; &lt; /etc/nginx/conf.d/default.template &gt; /etc/nginx/conf.d/default.conf \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &amp;&amp; exec nginx -g &#39;daemon off;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;</span>    
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>...</span>
</span></span></code></pre></div><ol start=4><li><code>docker compose</code> 를 실행하면 설정파일(.yml) 내 enviroment의 ${APP_URL}이 <code>.env</code> 에 정의한 example.com 으로 대치되어 Container 내 환경변수로 등록. 이후 command의 <code>envsubst</code> 명령어를 통해 nginx 설정 템플릿(default.template)에 정의한 환경변수 값인 ${APP_URL}이 Container에 등록된 환경변수 값(APP_URL)으로 대치한 결과를 default.conf 파일로 생성. 최종적으로 <code>.env</code> 파일의 APP_URL 값이 default.template의 ${APP_URL} 값으로 대치되는 것과 같음. 대치된 결과인 default.conf는 아래와 같으며 NginX Container는 이를 실행.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>### App (http)</span>
</span></span><span style=display:flex><span>server <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    listen 80;
</span></span><span style=display:flex><span>    server_name example.com;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Environment variables in Compose, Docker Docs, <a href=https://docs.docker.com/compose/environment-variables/#the-env-file>https://docs.docker.com/compose/environment-variables/#the-env-file</a>, 2020.03.29 검색.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>env(ironment) subst(itute). 환경변수에 정의한 값으로 대치하는 명령어.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>자세한 동작 과정은 <a href=#Appedix-2-NginX-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-%EB%82%B4-%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98-%EC%82%AC%EC%9A%A9>Appendix 2</a> 참조.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://letsencrypt.org/ko/docs/challenge-types/>ACME Challenge</a>.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>프록시 서버, 위키피디아, <a href=https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9D%EC%8B%9C_%EC%84%9C%EB%B2%84>https://ko.wikipedia.org/wiki/프록시_서버</a>, 2020.03.29 검색.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>포워드 프록시(Forward Proxy) 리버스 프록시(Reverse Proxy) 의 차이, 정광섭, <a href="https://www.lesstif.com/pages/viewpage.action?pageId=21430345">https://www.lesstif.com/pages/viewpage.action?pageId=21430345</a>, 2020.03.29 검색.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p><a href=https://hub.docker.com/_/nginx>https://hub.docker.com/_/nginx</a>의 Using environment variables in nginx configuration 항목 참조.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><footer class="mt-12 flex flex-wrap"><a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=https://inium.github.io/tags/docker>docker</a>
<a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=https://inium.github.io/tags/web>web</a>
<a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=https://inium.github.io/tags/reverse-proxy>reverse proxy</a>
<a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=https://inium.github.io/tags/nginx>nginx</a>
<a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=https://inium.github.io/tags/lets-encrypt>let's encrypt</a>
<a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=https://inium.github.io/tags/certbot>certbot</a></footer><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center p-6 pr-3 no-underline" href=https://inium.github.io/2020/04/docker-php-laravel-xdebug-vscode/><span class=mr-1.5>←</span><span>PHP Dockerfile 만들기 (with Laravel, Xdebug, vscode)</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline" href=https://inium.github.io/2020/03/build-dev-culture/><span>회사 소프트웨어 개발 문화를 만든 과정과 느낀점</span><span class=ml-1.5>→</span></a></nav><div id=disqus_thread></div><script>const disqusShortname="github-blog-inlee",script=document.createElement("script");script.src="https://"+disqusShortname+".disqus.com/embed.js",script.setAttribute("data-timestamp",+new Date),document.head.appendChild(script)</script></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2023
<a class=link href=https://inium.github.io/>inlee's blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>▷ Paper 6</a></footer></body></html>