<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#fff lang=ko-kr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>PHP Dockerfile 만들기 (with Laravel, Xdebug, vscode) - inlee's blog</title><meta name=theme-color><meta name=description content="PHP docker 공식 이미지는 PHP만 제공하기 때문에 추가로 필요한 패키지들은 별도로 설치하여 사용해야 한다. 그리고 Laravel과 같이 특정 라이브러리들을 필수로 하는 프레임워크도 있기 때문에 대부분의 사용자들은 패키지들을 추가한 Dockerfile을 정의하여 사용한다.
이 글은 PHP docker 공식 이미지에 일반 PHP와 Laravel 기반의 어플리케이션 개발/운영 환경을 포함하는 Dockerfile을 만든 내용이다.이를 위해 PHP에서 필수라 생각되는 패키지와 Laravel에서 요구하는 필수 패키지 설치와 실행 설정을 하였다. 추가로 PHP 코드 디버깅(Debugging)을 위한 Xdebug 설정과 Visual Studio Code 에서의 설정을 하였다."><meta name=author content="inlee"><link rel="preload stylesheet" as=style href=https://inium.github.io/main.min.css><link rel=preload as=image href=https://inium.github.io/theme.png><link rel=preload as=image href="https://avatars.githubusercontent.com/u/9084843?v=4"><link rel=preload as=image href=https://inium.github.io/github.svg><link rel=preload as=image href=https://inium.github.io/rss.svg><link rel=icon href=https://inium.github.io/favicon.ico><link rel=apple-touch-icon href=https://inium.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.101.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-153151440-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-153151440-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="PHP Dockerfile 만들기 (with Laravel, Xdebug, vscode)"><meta property="og:description" content="PHP docker 공식 이미지는 PHP만 제공하기 때문에 추가로 필요한 패키지들은 별도로 설치하여 사용해야 한다. 그리고 Laravel과 같이 특정 라이브러리들을 필수로 하는 프레임워크도 있기 때문에 대부분의 사용자들은 패키지들을 추가한 Dockerfile을 정의하여 사용한다.
이 글은 PHP docker 공식 이미지에 일반 PHP와 Laravel 기반의 어플리케이션 개발/운영 환경을 포함하는 Dockerfile을 만든 내용이다.이를 위해 PHP에서 필수라 생각되는 패키지와 Laravel에서 요구하는 필수 패키지 설치와 실행 설정을 하였다. 추가로 PHP 코드 디버깅(Debugging)을 위한 Xdebug 설정과 Visual Studio Code 에서의 설정을 하였다."><meta property="og:type" content="article"><meta property="og:url" content="https://inium.github.io/2020/04/docker-php-laravel-xdebug-vscode/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-19T02:37:43+00:00"><meta property="article:modified_time" content="2020-04-19T02:37:43+00:00"><meta itemprop=name content="PHP Dockerfile 만들기 (with Laravel, Xdebug, vscode)"><meta itemprop=description content="PHP docker 공식 이미지는 PHP만 제공하기 때문에 추가로 필요한 패키지들은 별도로 설치하여 사용해야 한다. 그리고 Laravel과 같이 특정 라이브러리들을 필수로 하는 프레임워크도 있기 때문에 대부분의 사용자들은 패키지들을 추가한 Dockerfile을 정의하여 사용한다.
이 글은 PHP docker 공식 이미지에 일반 PHP와 Laravel 기반의 어플리케이션 개발/운영 환경을 포함하는 Dockerfile을 만든 내용이다.이를 위해 PHP에서 필수라 생각되는 패키지와 Laravel에서 요구하는 필수 패키지 설치와 실행 설정을 하였다. 추가로 PHP 코드 디버깅(Debugging)을 위한 Xdebug 설정과 Visual Studio Code 에서의 설정을 하였다."><meta itemprop=datePublished content="2020-04-19T02:37:43+00:00"><meta itemprop=dateModified content="2020-04-19T02:37:43+00:00"><meta itemprop=wordCount content="1106"><meta itemprop=keywords content="docker,php,xdebug,vscode,"><meta name=twitter:card content="summary"><meta name=twitter:title content="PHP Dockerfile 만들기 (with Laravel, Xdebug, vscode)"><meta name=twitter:description content="PHP docker 공식 이미지는 PHP만 제공하기 때문에 추가로 필요한 패키지들은 별도로 설치하여 사용해야 한다. 그리고 Laravel과 같이 특정 라이브러리들을 필수로 하는 프레임워크도 있기 때문에 대부분의 사용자들은 패키지들을 추가한 Dockerfile을 정의하여 사용한다.
이 글은 PHP docker 공식 이미지에 일반 PHP와 Laravel 기반의 어플리케이션 개발/운영 환경을 포함하는 Dockerfile을 만든 내용이다.이를 위해 PHP에서 필수라 생각되는 패키지와 Laravel에서 요구하는 필수 패키지 설치와 실행 설정을 하였다. 추가로 PHP 코드 디버깅(Debugging)을 위한 Xdebug 설정과 Visual Studio Code 에서의 설정을 하였다."></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href=https://inium.github.io/>inlee's blog</a>
<a class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"></a></div><a class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"></a>
<script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg=`"#fff"`.replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"><a class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/inium target=_blank></a>
<a class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://inium.github.io/index.xml target=_blank></a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">PHP Dockerfile 만들기 (with Laravel, Xdebug, vscode)</h1><div class="text-sm opacity-60"><time>Apr 19, 2020</time>
<span class=mx-1>&#183;</span>
<span>inlee</span></div></header><section><p><a href=https://hub.docker.com/_/php>PHP docker 공식 이미지</a>는 PHP만 제공하기 때문에 추가로 필요한 패키지들은 별도로 설치하여 사용해야 한다. 그리고 Laravel과 같이 특정 라이브러리들을 <a href=https://laravel.kr/docs/7.x/installation>필수</a>로 하는 프레임워크도 있기 때문에 대부분의 사용자들은 패키지들을 추가한 Dockerfile을 정의하여 사용한다.</p><p>이 글은 PHP docker 공식 이미지에 일반 PHP와 Laravel 기반의 어플리케이션 개발/운영 환경을 포함하는 Dockerfile을 만든 내용이다.이를 위해 PHP에서 필수라 생각되는 패키지와 Laravel에서 요구하는 <a href=https://laravel.kr/docs/7.x/installation>필수 패키지</a> 설치와 실행 설정을 하였다. 추가로 PHP 코드 디버깅(Debugging)을 위한 <a href=https://xdebug.org>Xdebug</a> 설정과 <a href=https://code.visualstudio.com>Visual Studio Code</a> 에서의 설정을 하였다.</p><h3 id=개요>개요</h3><p>PHP의 경우 일반적으로 Document Root는 소스코드 저장경로로 하여 실행한다. <a href=https://wordpress.org>Wordpress</a>, <a href=http://codeigniter.com>Codeigniter</a>가 대표적이다. 그러나 <a href=http://laravel.com>Laravel</a>과 같이 Document Root를 소스코드 내 특정 디렉터리(/public)로 설정하여 실행하기도 한다.</p><p>Docker를 이용하는 경우 전자라면 컨테이너(Container)에 소스코드 전체를 공유하여 별 다른 설정 없이 사용할 수 있지만 후자의 경우라면 소스코드 전체를 컨테이너에 공유한 후 Document Root를 별도로 설정해 주어야 한다. Apache 기반의 docker PHP를 이용한다면 <code>.htaccess</code> 파일의 설정을 통해 쉽게 해결이 가능하겠지만 이는 NginX와 연결하여 사용할 경우라면 근본적인 해결책이 되지 않는다.</p><p>이 글에서는 앞서 언급한 두가지 경우, 일반 PHP와 Laravel 프로젝트에 대해 모두 사용할 수 있도록 Docker 기반에서 소스코드 저장경로와 Laravel을 실행하는 <code>/public</code> 디렉터리 모두 Document Root로 하는 Docker 환경설정을 구성한 내용에 대해 서술하였다. 또한 NginX와 사용하기 위해 <a href=#Appendix-php-fpm>php-fpm</a> 기반에서 설정을 진행했다. 추가로 PHP 코드 디버깅(Debugging)을 위한 Xdebug 설정과 Visual Studo Code에서의 설정을 한 내용에 대해 서술하고자 한다.</p><h3 id=구성>구성</h3><p>이 글에서 언급하는 Dockerfile과 관련 항목의 구성은 PHP docker 공식 이미지 중 php-fpm을 기반으로 하였으며 일반적인 PHP 어플리케이션과 Laravel로 구현된 어플리케이션의 동작을 모두 가능하게 하였다.</p><h4 id=base-php-fpm>Base: php-fpm</h4><p>이 글의 Dockerfile 구현은 운영(Production) 모드에서 Reverse Proxy 혹은 웹 서버로 사용하는 NginX와 사용하고자 php-fpm을 기반으로 하였다. 참고로 Apache는 내장 php 모듈이 있어 php 파일을 자체적으로 처리하지만, NginX는 없기 때문에 php-fpm을 통해 php 파일을 처리해야 한다.</p><p>개발(Development) 모드에서는 PHP 내장 서버(Built-in web server)를 이용하도록 하였다.</p><h4 id=packages>Packages</h4><p>설치하여 사용하는 패키지는 Laravel에서 필수로 요구하는 패키지와 이미지를 다루는 gd, PHP 패키지 매니저인 composer, git, curl, wget, openssl, zip, conv, opcache 그리고 개발 모드에서 사용할 Xdebug를 사용하도록 하였다.</p><h4 id=ports>Ports</h4><p>Port는 80번과 9000번 2가지를 사용하였다. 그런데 운영 모드에서 사용하는 php-fpm의 기본 Port와 Xdebug의 Port가 같은 9000번을 사용하여 혼란을 줄 수 있어 php-fpm에서 사용하는 Port를 80 번으로 변경하였다. 자세한 내용은 아래와 같다.</p><ul><li>80번: development, production 웹 서버용으로 사용.<ul><li>development: php 명령어를 이용해 PHP 내장 서버 실행.</li><li>production: php-fpm 명령어 실행. <strong>php-fpm 에서 사용하는 기본 Port는 9000번이나 xdebug에서 사용하는 Port 번호와 혼동되지 않도록 80번으로 강제 변경하여 사용하도록 설정.</strong>. 즉 개발/운영 모드에서 사용하는 Port를 동일한 80번으로 통일.</li></ul></li><li>9000번: Xdebug 용으로 사용</li></ul><h4 id=volumes>Volumes</h4><p>아래와 같이 2개의 Volume을 사용하도록 하였다.</p><ul><li>/var/www/html: 웹 서버 Root.</li><li>/usr/local/etc/php/conf.d/php.ini: PHP 환경설정 파일.</li></ul><h4 id=환경변수>환경변수</h4><p>동작 환경에 사용되는 환경 변수는 development / production 모드 설정과 Laravel 사용 여부이며 내용은 아래와 같다.</p><ul><li>DOCKER_ENV: 운영 모드. development / production 중 1이며 기본값은 development.</li><li>DOCKER_LARAVEL: Laravel 프레임워크 사용 여부. true / false 중 1이며 기본값은 false.</li></ul><h4 id=실행>실행</h4><p><code>docker run</code> 명령어로 실행 시 설정된 환경변수를 이용해 아래와 같이 실행하도록 구현하였다.</p><ol><li>DOCKER_ENV 값이 development일 경우, 개발모드로 실행.</li></ol><ul><li>Xdebug 활성화.</li><li>PHP 내장 서버(built-in web server) 실행.</li></ul><ol start=2><li>DOCKER_ENV 값이 production일 경우, 운영모드로 실행.</li></ol><ul><li>Xdebug 활성화 하지 않음.</li><li>php-fpm 명령어 실행.</li></ul><p><a href=https://www.php.net/manual/en/features.commandline.webserver.php>PHP 내장 서버</a>는 개발 모드에서 사용이 되고 PHP 파일을 자체적으로 처리하며 CLI로 동작한다. 하나의 프로세스로 동작하기 때문에 요청(Request)이 Block될 경우에는 프로그램이 중지된다.</p><p>development / production 모드에 상관없이 DOCKER_LARAVEL 값이 true인 경우, Laravel 프로젝트의 실행 디렉터리인 <code>/public</code> 디렉터리의 파일을 실행한다. 이는 Laravel 여부에 상관없이 <code>/public</code> 디렉터리의 파일을 실행하는 프로젝트라면 true로 설정하여 사용 가능하다.</p><h3 id=xdebug-설정>Xdebug 설정</h3><p><code>docker run</code> 명령 실행 시 DOCKER_ENV 환경변수의 값이 development(개발모드)일 경우 IDE에서의 디버깅을 할 수 있도록 Remote 설정을 포함한 Xdebug 활성화를 하였다. 그리고 사용하는 개발도구인 Visual Studio Code의 설정은 아래와 같이 하였다.</p><h4 id=xdebug-활성화>Xdebug 활성화</h4><p>Container를 개발모드로 실행 시 Xdebug가 아래 Docker 에서 제공하는 명령어로 활성화 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker-php-ext-enable xdebug
</span></span></code></pre></div><p>이 명령어는 php 설정 파일이 저장되는 디렉터리인 <code>/usr/local/etc/php/conf.d/</code> 디렉터리에 <code>docker-php-ext-xdebug.ini</code> 파일을 생성한 후 아래와 같이 Xdebug 설정이 기록되어 실행된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#75715e># docker-php-ext-xdebug.ini</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>zend_extension</span><span style=color:#f92672>=</span><span style=color:#e6db74>/usr/local/lib/php/extensions/no-debug-non-zts-20190902/xdebug.so</span>
</span></span></code></pre></div><p>설정이 완료되면, 페이지 로딩 시 오류가 발생하면 Xdebug가 오류를 출력해준다.</p><h4 id=remote-설정>Remote 설정</h4><p>Xdebug는 페이지 로딩 시 오류가 있을 경우 관련 내용을 출력하지만, 특정 시점에서의 변수값, Call Stack 등을 확인을 하고자 할 때에는 Xdebug의 remote 관련 옵션을 이용해 IDE와 연동하여 사용할 수 있다. 이 기능을 사용하려면 아래와 같이 Xdebug 설정 파일에 remote 관련 설정을 해 주어야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#75715e># docker-php-ext-xdebug.ini</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xdebug.default_enable</span><span style=color:#f92672>=</span><span style=color:#e6db74>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xdebug.remote_enable</span><span style=color:#f92672>=</span><span style=color:#e6db74>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xdebug.remote_port</span><span style=color:#f92672>=</span><span style=color:#e6db74>9000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xdebug.remote_handler</span><span style=color:#f92672>=</span><span style=color:#e6db74>dbgp</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xdebug.remote_connect_back</span><span style=color:#f92672>=</span><span style=color:#e6db74>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xdebug.remote_host</span><span style=color:#f92672>=</span><span style=color:#e6db74>host.docker.internal</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xdebug.idekey</span><span style=color:#f92672>=</span><span style=color:#e6db74>VSCODE</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xdebug.remote_autostart</span><span style=color:#f92672>=</span><span style=color:#e6db74>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xdebug.remote_log</span><span style=color:#f92672>=</span><span style=color:#e6db74>/usr/local/etc/php/xdebug.log</span>
</span></span></code></pre></div><p>Xdebug의 remote 설정과 관련된 주요 내용은 아래와 같다<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><ul><li>xdebug.remote_enable: Remote 디버깅 사용 여부</li><li>xdebug.remote_port : Remote와의 통신에 사용할 port 번호. Xdebug 기본값인 9000 번으로 설정. 이 글의 구현에서는 9000 포트가 php-fpm과 중복되기 때문에, php-fpm의 동작 port를 80으로 변경.</li><li>xdebug.remote_hosts: Remote와의 통신에 사용할 IP 주소. Docker를 사용할 경우 host.docker.internal 입력.</li><li>xdebug.remote_autostart: Xdebug 사용 시 GET/POST 등으로 remote debugging 사용을 알려야 하는데 이를 활성화하면 사용 알림 필요 없이 자동으로 시작.</li></ul><p>여기서 host.docker.internal은 Docker 버전 18.03 이후부터 제공하는 Docker 컨테이너 내부에서 Host를 호출할 때 사용하는 DNS name 이다<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. 즉 Host의 IP 주소이며 컨테이너는 remote_host와 remote_port를 이용해 Host와 통신한다.</p><p>이 글의 구현에서는 추후 IDE와 사용될 것을 고려하여 Container 실행 시 Xdebug 활성화와 Remote 설정을 동시에 진행한다.</p><h4 id=visual-studio-code-설정>Visual Studio Code 설정</h4><p>Container에 Xdebug 활성화와 remote 설정이 완료되면 Visual Studio Code에서 접근할 수 있도록 아래와 같이 <code>launch.json</code> 파일을 생성<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>한 후 아래와 같이 Xdebug 연결을 위한 설정을 해 주어야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#75715e>// launch.json
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;version&#34;</span>: <span style=color:#e6db74>&#34;0.2.0&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;configurations&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;Listen for XDebug&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;php&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;request&#34;</span>: <span style=color:#e6db74>&#34;launch&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;port&#34;</span>: <span style=color:#ae81ff>9000</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;log&#34;</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;externalConsole&#34;</span>: <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;pathMappings&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;/var/www/html&#34;</span>: <span style=color:#e6db74>&#34;${workspaceRoot}&#34;</span>,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;ignore&#34;</span>: [
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;**/vendor/**/*.php&#34;</span>
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>    }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>launch.json</code> 파일의 주요 설정은 아래와 같다.</p><ul><li>port: Container의 xdebug.remote_port와 같은 port 설정</li><li>pathMappings: 좌측에는 Container의 working directory 이며 우측에는 Visual Studio Code에서 Open한 코드의 디렉터리로 &ldquo;${workspaceRoot}&rdquo; 입력.</li><li>ignore: 디버깅을 무시할 파일 목록. 위의 예시에서는 <code>composer</code>로 설치된 패키지 전부를 무시하도록 설정.</li></ul><h3 id=구현-결과>구현 결과</h3><p>구현 결과와 실행 방법은 아래 Repository에 업로드 하였다.</p><ul><li><a href=https://github.com/inium/docker-php>https://github.com/inium/docker-php</a></li></ul><h3 id=마치며>마치며</h3><p>이 글은 PHP를 이용해 일반적인 어플리케이션과 Laravel을 동시에 사용하는 Dockerfile을 구현한 것에 대해 정리한 내용이다.</p><p>구현하게 된 계기는 Laravel로 개발 환경을 전환하면서 이에 맞는 Docker 설정이 필요했고 더불어 기존 개발된 프로젝트도 대응할 수 있도록 하는 데에 목적을 두었다. Laravel은 <a href=https://laradock.io>laradock</a>이라는 개발 환경을 제공하는 오픈 소스 프로젝트가 있다. 그러나 많은 Docker Image를 실행할 수 있도록 설정을 포함하고 있어 처음 사용하는 사용자들에게는 복잡하다고 판단되었고 또한 기존 구현되었던 프로젝트 개발/운영에는 맞지 않다고 판단되어 직접 구현하게 되었다. 또한 Xdebug를 추가함으로써 특정 시점의 변수 값이나 Call Stack을 확인하여 효율적인 개발이 가능하게 하고자 하였다.</p><p>관련 내용은 많이 공개되어 있으며 구현은 어렵지 않았다. 때문에 관련 내용을 알고 있으면 이 글의 내용은 어렵지 않을 것이라 생각된다.</p><h3 id=appendix-php-fpm>Appendix. php-fpm</h3><p>fpm은 FastCGI Process Manager의 약자로 직역하면 CGI를 빠르게 처리하는 프로세스 관리자 라는 뜻이다. CGI는 웹 서버가 처리할 수 없는 데이터의 처리를 하는 외부 프로그램을 말하며 Fast가 붙은 것은 CGI 처리를 빠르게 한 것을 말한다<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>. php-fpm은 PHP 파일을 처리하는 FastCGI 이며 주로 NginX와 같이 사용된다.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>자세한 내용은 XDebug docs(<a href=https://xdebug.org/docs/all_settings>https://xdebug.org/docs/all_settings</a>), 생활코딩 Xdebug(<a href=https://opentutorials.org/course/692/3758>https://opentutorials.org/course/692/3758</a>) 참조.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://docs.docker.com/docker-for-mac/networking/#use-cases-and-workarounds>https://docs.docker.com/docker-for-mac/networking/#use-cases-and-workarounds</a>, 2020.04.16 검색.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://docs.docker.com/docker-for-windows/networking/>https://docs.docker.com/docker-for-windows/networking/</a>, 2020.04.16 검색.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Docker에서 macOS 호스트 포트에 접근하기, SEORENN NOTEBOOK, <a href=https://seorenn.tistory.com/20>https://seorenn.tistory.com/20</a>, 2020.04.16 검색.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>launch.json 파일 생성은 <a href=https://code.visualstudio.com/docs/editor/debugging>https://code.visualstudio.com/docs/editor/debugging</a> 참조.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>여러개의 Process를 사전에 생성한 후 Process pool 생성. 이후 요청이 들어오면 Pool로부터 처리할 process를 가져와 처리한 후 완료되면 다시 pool에 사용 가능한 상태로 복귀.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><footer class="mt-12 flex flex-wrap"><a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=https://inium.github.io/tags/docker>docker</a>
<a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=https://inium.github.io/tags/php>php</a>
<a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=https://inium.github.io/tags/xdebug>xdebug</a>
<a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=https://inium.github.io/tags/vscode>vscode</a></footer><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center p-6 pr-3 no-underline" href=https://inium.github.io/2020/08/create-laravel-board/><span class=mr-1.5>←</span><span>회고 - Laravel 게시판 패키지 구현 과정과 고민들</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline" href=https://inium.github.io/2020/04/docker-nginx-certbot/><span>Docker를 이용한 Reverse Proxy 서버 구성 및 자동화</span><span class=ml-1.5>→</span></a></nav><div id=disqus_thread></div><script>const disqusShortname="github-blog-inlee",script=document.createElement("script");script.src="https://"+disqusShortname+".disqus.com/embed.js",script.setAttribute("data-timestamp",+new Date),document.head.appendChild(script)</script></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2022
<a class=link href=https://inium.github.io/>inlee's blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>▷ Paper 6</a></footer></body></html>